# 第四课作业

本次课作业有明确的说明和细节指示，所以那就按照说明的要求来，不整太复杂的东西。

但是比普通作业不一样的地方在于，这里依然尝试结合真实世界里面的业务场景来进行实现，这里取的是“第三方平台消息通知”这个业务，刚好也是有三个平台：企业微信、钉钉、飞书。当然实际情况是还有“微信”，这里就暂不去涉及，如果实现方案的协议思路是对的，后续加一个平台就是加多一个具体的实现即可。

在真实世界中，一个 ToB 类型的业务系统需要支持三个大型平台进行业务交互，其中会用到消息推送这个能力，而这个能力在业务上是属于能与核心业务能力平起平坐的，但是在实际情况中，很少有能力能够同时针对三个平台进行统一化建模，基本上还是处于能用就行、修修补补的脚本式文本替换处理的状态，很难从中看出逻辑的统一性和标准化处理，也更难进行调试和对接，业务系统的可维护性极差。

至于是为什么，就不做过多阐述了。

## 第一题

使用枚举包裹三个不同的类型，并放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法。

定义三个不同的类型，使用Trait Object，将其放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法。

同时，说明其上两种不同实现方法的区别。

---

在不同的业务场景下，分别向三个平台所发送的消息内容会有所差异，以及由于目标平台的差异，同一个业务场景的消息格式也会有很大差异。

为了统一管理这些消息内容的“业务场景=>消息推送“的逻辑分发，首先需要分别为三个平台的消息内容建立“模版”，然后通过模版+业务参数最终渲染为不同平台的目标格式和内容。

假设有这么三个类型，对应真实世界里面的三个平台的业务对象描述，这是最终渲染的目标，这个具体格式是平台定义的，我们只是对接实现即可：

- 企业微信消息
- 钉钉消息
- 飞书消息

由于每个平台自身的消息类型都是多种多样的，所以实际上都会把它们已知的消息类型都分别用枚举进行封装起来，甚至由于平台内部不同的业务属性导致格式不同，但这里目前不去深入，且并不影响外层逻辑设计，所以都声明为结构体以体现类型的逻辑关系。

再有三个业务模版类型，用于定义和管理不同业务场景下的消息内容和格式，这就是我们自身业务定义的，可通过我们自身的业务场景进行不同的定义：

- 企业微信模版
- 钉钉模版
- 飞书模版

然后这个模版各自都有一个方法，用于分别处理为各自平台的目标数据格式：

- to_third_party_msg

这样，有两种实现方案：

- 使用枚举 Enum，定义一个 ThirdPartyMsg 枚举来包含三种不同平台的消息类型，定义一个 Template 枚举来包含三个不同平台的模版类型。
- 使用 Trait Object，定义一个 ToThirdPartyMsg 并声明一个方法 to_third_party_msg，名称是否有更好的后面再说，然后让三个模版类型都实现这个 ToThirdPartyMsg

此次仅限于实现基本代码架构，不实现和过于关注内部字段细节。

### 编译&运行

> 代码内设定了一个 10000 次循环调用 to_third_party_msg 的控制参数

```sh
# 枚举 Enum 版本
cargo build -r --bin lesson0401
# 得到文件大小：533 KB

# 运行
./target/release/lesson0401
# 耗时：Time elapsed in run() is: 470.268416ms（负载不同可能耗时不同，绝对值无意义，看相对值差异）
```

```sh
# Trait Object 版本
cargo build -r --bin lesson0402
# 得到文件大小 534 KB

# 运行
./target/release/lesson0402
# 耗时：Time elapsed in run() is: 440.483334ms（负载不同可能耗时不同，绝对值无意义，看相对值差异）
```

疑问（未必有答案）：

1. 在此代码仓库中，为何 dyn Trait 版本比 Enum 版本耗时更优？

2. 在此代码仓库中，为何 dyn Trait 版本文件大小更大？

区别（个人认为）：

1. 在业务上，枚举更适合确实能够枚举完整的业务场景，而 Trait Object 更适合无法知晓具体是什么类型，但是又有共同的协议的类型的场景。
2. 如果是想要覆盖场景而不遗漏，比较适合用 Enum，它是一个更封闭的面向内部世界
3. 如果是想要标定一个协议，但不限制谁来实现或不知道谁会实现，比较适合用 Trait Object，它是一个完全开放的面向外部世界
4. Trait Object 更为抽象，如果不是对业务或使用场景有很深的理解和有一定的抽象设计能力，可能早期如果用 Enum 能满足业务要求，那就 Enum 更合适些，毕竟更容易理解。

## 第二题

搜索相关文档，为你自己定义的一个类型或多个类型实现加法运算（用符号 +），并构思使用Trait Object实现类型方法的调用。

---

