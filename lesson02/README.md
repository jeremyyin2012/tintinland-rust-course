# 所有权、不可变引用、可变引用

> 所有权、不可变引用、可变引用这三者的规则或特性

在大多数常见的编程语言中，一个值是可以让多个变量指向于它的（赋值）。由于有多个变量指向于一个值，则需要有一个机制来管理每一个值的指向关系。

一种是让程序员手动进行控制，即自行决定哪里申请、自行决定哪里进行释放。

另一种是引入自动回收机制（GC），专门来管理变量和值的关系，以便进行内存的管理。

但都是有利有弊，要么无法做到完全的安全保证，要么无法做到极致的高效管理。

那么，有没有一种办法，可以同时做到呢？

分析一下：

你看，多指向，这是多对一的关系，手动管理起来麻烦的很还容易出错，自动管理又总是不够及时还要额外耽搁好一些运行时间。

那有没有可能做成一对一的关系，变量啥时候申请，其实我们是知道的，但是变量啥时候消失，这个比较难。

如果能做成一对一的关系，这样它（值）就只有两种情况：活着/死亡；要么你拿着，要么他拿着，要是没人拿着，它就死亡了。

但是如果再把这个关系给它规定一个有效范围，强制把这些值的使用者（变量）都给排个队，前面的用完后面用，这样就不可能同时存在多个变量抢一个值的情况了，也由于排了这个队，换人的时候，总是能保证及时释放掉数据，这样内存也就自动管理好了。

这样看起来，是不是整个数据的流动模型就能简化到极致呢。

但是要怎么才能规定有效范围呢？

不如，先来两括号{}，这刚好是代码块的形式。

那又怎么给它们拍个队呢？那就按顺序来排，赋值，那就把它交给你了（move），但你说只是想知道在哪里（引用），那我就告诉你一个数（pointer）就行，用完了就告诉下我。

但是对于明明已经知道大小了（整数、浮点数、布尔值、编码好的字符、或者前面这几个组成的元组）的值，那就直接复制就行，还不用再拖一个引用的尾巴，逻辑更简单还更节省空间。

你如果不用改它（值）的，多告诉几个人在哪里（引用地址）也无妨，对它（值）没啥影响；

但是如果是想要改它（值），那得我说能改才行（mut），而且在这个时间线上，一个人没改完，另外一个不能进来改，改完了就收回来，谁要改再申请。

这个模型目前看起来有点意思，正经引入几个概念，做下规定吧。

## 所有权

- 每一个值，都有一个所有者
- 任何时刻，一个值仅被一个所有者所拥有
- 所有者所在的作用域一旦结束，就把值释放掉

作用域：一对花括号内，变量声明进行申请，花括号结束进行释放。

行为：

- 新赋值，一个值就有了一个所有者
- 变量直接赋值给变量，
  - 如果这个值编译时无法知晓其大小，这个值的所有者就转移给新的变量
  - 但如果这个值是编译时已知大小，就会复制一个再赋值给新的变量 Copy
    - 整数
    - 浮点数
    - 布尔值
    - 编码的字符
    - 仅前面这几个组合而成的元组

## 引用

引用的本质就是一个整数，是一个有效的内存地址，术语叫：非空指针。

引用在这里的目的，是为了解决频繁转移值本身的所有权的问题。

由于引用本质是一个整数，所以引用的直接赋值，本质又是直接复制整数进行赋值。

作用域：变量声明[生效]->最后一次调用[失效]

### 不可变引用

没有特别声明的话，默认加&就是不可变引用。

由于不会对值本身造成任何影响，在值的所有者所在作用域内，可以有多个不可变引用同时引用同一个值。

不可变引用赋值给新的变量，可以直接复制这个引用地址赋值即可，即 Copy。

### 可变引用

可变引用的前提首先是需要所有者特别声明：我是可变的。

```rust
let mut a = 10u32;
```

然后在决定使用它的引用时，把 ```mut a``` 看作一个整体：可变的a，再在前面加&符号得到可变引用。

```rust
let b = &mut a
```

由于可变引用会对值本身造成影响，所以需严格限制，对于一个值：

- 在可变引用作用域（变量声明[生效]->最后一次调用[失效]）之间不能有第二个可变引用，即同时间有且仅有一个可变引用存在，话说就是你不能同时接两家命令也不能接一家名了但事还没完你又接另一家。
- 在可变引用作用域（变量声明[生效]->最后一次调用[失效]）之间也不能有不可变引用，即可变引用和不可变引用之间的作用域不能交叠，话说就是你不能一下子可变但事还没完你又不可变，或者你本来不可变可事儿还没完你又说可变，那这个排队规则就乱套了。
- 如果可变引用被赋值给新的变量，那么必须转移这个引用的所有者，即所有权转移move，形成新的变量作用域。

## 总结

将多对一的关系直接极致地简化为一对一关系，引入唯一所有权的概念进行抽象，又将本来括号内的一大片作用域空间又分割为一段一段连续非交叉的作用域空间，这个模型极致地简化了变量与值的管理难度，利用作用域进入退出机制实现自动内存申请和释放，在即保证了安全的同时，又实现了一个非常极致且高效的内存管理模型，同时还基本符合人类思维，虽然有些地方部分反直觉，那是因为模型理解的问题，以及受其它语言固有思维的影响导致。

